//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections;

namespace NLog.Appenders
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="NLog.Appenders.Appender"/> objects.
	/// </summary>
	[Serializable]
public 
  class AppenderCollection : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="AppenderCollection"/>.
	    /// </summary>
        public interface IAppenderCollectionEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            NLog.Appenders.Appender Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private NLog.Appenders.Appender[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>AppenderCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>AppenderCollection</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static AppenderCollection Synchronized(AppenderCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncAppenderCollection(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>AppenderCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>AppenderCollection</c> wrapper that is read-only.
		/// </returns>
        public static AppenderCollection ReadOnly(AppenderCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyAppenderCollection(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>AppenderCollection</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public AppenderCollection()
		{
			m_array = new NLog.Appenders.Appender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>AppenderCollection</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
		///	</param>
		public AppenderCollection(int capacity)
		{
			m_array = new NLog.Appenders.Appender[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>AppenderCollection</c> class
		///		that contains elements copied from the specified <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
		public AppenderCollection(AppenderCollection c)
		{
			m_array = new NLog.Appenders.Appender[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>AppenderCollection</c> class
		///		that contains elements copied from the specified <see cref="NLog.Appenders.Appender"/> array.
		/// </summary>
		/// <param name="a">The <see cref="NLog.Appenders.Appender"/> array whose elements are copied to the new list.</param>
		public AppenderCollection(NLog.Appenders.Appender[] a)
		{
			m_array = new NLog.Appenders.Appender[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected AppenderCollection(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>AppenderCollection</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>AppenderCollection</c> to a one-dimensional
		///		<see cref="NLog.Appenders.Appender"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Appenders.Appender"/> array to copy to.</param>
		public virtual void CopyTo(NLog.Appenders.Appender[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>AppenderCollection</c> to a one-dimensional
		///		<see cref="NLog.Appenders.Appender"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Appenders.Appender"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(NLog.Appenders.Appender[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="NLog.Appenders.Appender"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual NLog.Appenders.Appender this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="NLog.Appenders.Appender"/> to the end of the <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Appenders.Appender"/> to be added to the end of the <c>AppenderCollection</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(NLog.Appenders.Appender item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>AppenderCollection</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new NLog.Appenders.Appender[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="AppenderCollection"/>.
		/// </summary>
		public virtual object Clone()
		{
			AppenderCollection newColl = new AppenderCollection(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="NLog.Appenders.Appender"/> is in the <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Appenders.Appender"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>AppenderCollection</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(NLog.Appenders.Appender item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="NLog.Appenders.Appender"/>
		///		in the <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Appenders.Appender"/> to locate in the <c>AppenderCollection</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>AppenderCollection</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(NLog.Appenders.Appender item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>AppenderCollection</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="NLog.Appenders.Appender"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, NLog.Appenders.Appender item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="NLog.Appenders.Appender"/> from the <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Appenders.Appender"/> to remove from the <c>AppenderCollection</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="NLog.Appenders.Appender"/> was not found in the <c>AppenderCollection</c>.
		/// </exception>
		public virtual void Remove(NLog.Appenders.Appender item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			NLog.Appenders.Appender[] temp = new NLog.Appenders.Appender[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>AppenderCollection</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>AppenderCollection</c>.</returns>
		public virtual IAppenderCollectionEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>AppenderCollection</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						NLog.Appenders.Appender[] temp = new NLog.Appenders.Appender[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new NLog.Appenders.Appender[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>AppenderCollection</c> to the current <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="x">The <c>AppenderCollection</c> whose elements should be added to the end of the current <c>AppenderCollection</c>.</param>
		/// <returns>The new <see cref="AppenderCollection.Count"/> of the <c>AppenderCollection</c>.</returns>
		public virtual int AddRange(AppenderCollection x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="NLog.Appenders.Appender"/> array to the current <c>AppenderCollection</c>.
		/// </summary>
		/// <param name="x">The <see cref="NLog.Appenders.Appender"/> array whose elements should be added to the end of the <c>AppenderCollection</c>.</param>
		/// <returns>The new <see cref="AppenderCollection.Count"/> of the <c>AppenderCollection</c>.</returns>
		public virtual int AddRange(NLog.Appenders.Appender[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (NLog.Appenders.Appender)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((NLog.Appenders.Appender)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((NLog.Appenders.Appender)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((NLog.Appenders.Appender)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (NLog.Appenders.Appender)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((NLog.Appenders.Appender)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="AppenderCollection"/>.
		/// </summary>
		private class Enumerator : IEnumerator, IAppenderCollectionEnumerator
		{
			#region Implementation (data)
			
			private AppenderCollection m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(AppenderCollection tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public NLog.Appenders.Appender Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncAppenderCollection : AppenderCollection
        {
            #region Implementation (data)
            private AppenderCollection m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncAppenderCollection(AppenderCollection list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Appenders.Appender[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Appenders.Appender[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Appenders.Appender this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(NLog.Appenders.Appender x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(NLog.Appenders.Appender x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Appenders.Appender x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Appenders.Appender x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(NLog.Appenders.Appender x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IAppenderCollectionEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(AppenderCollection x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(NLog.Appenders.Appender[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyAppenderCollection : AppenderCollection
        {
            #region Implementation (data)
            private AppenderCollection m_collection;
            #endregion

            #region Construction
            internal ReadOnlyAppenderCollection(AppenderCollection list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Appenders.Appender[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Appenders.Appender[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Appenders.Appender this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(NLog.Appenders.Appender x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(NLog.Appenders.Appender x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Appenders.Appender x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Appenders.Appender x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(NLog.Appenders.Appender x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IAppenderCollectionEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(AppenderCollection x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(NLog.Appenders.Appender[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
	
namespace NLog.Filters
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="NLog.Filters.Filter"/> objects.
	/// </summary>
	[Serializable]
public 
  class FilterCollection : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="FilterCollection"/>.
	    /// </summary>
        public interface IFilterCollectionEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            NLog.Filters.Filter Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private NLog.Filters.Filter[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>FilterCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>FilterCollection</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static FilterCollection Synchronized(FilterCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncFilterCollection(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>FilterCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>FilterCollection</c> wrapper that is read-only.
		/// </returns>
        public static FilterCollection ReadOnly(FilterCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyFilterCollection(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>FilterCollection</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public FilterCollection()
		{
			m_array = new NLog.Filters.Filter[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>FilterCollection</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>FilterCollection</c> is initially capable of storing.
		///	</param>
		public FilterCollection(int capacity)
		{
			m_array = new NLog.Filters.Filter[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>FilterCollection</c> class
		///		that contains elements copied from the specified <c>FilterCollection</c>.
		/// </summary>
		/// <param name="c">The <c>FilterCollection</c> whose elements are copied to the new collection.</param>
		public FilterCollection(FilterCollection c)
		{
			m_array = new NLog.Filters.Filter[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>FilterCollection</c> class
		///		that contains elements copied from the specified <see cref="NLog.Filters.Filter"/> array.
		/// </summary>
		/// <param name="a">The <see cref="NLog.Filters.Filter"/> array whose elements are copied to the new list.</param>
		public FilterCollection(NLog.Filters.Filter[] a)
		{
			m_array = new NLog.Filters.Filter[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected FilterCollection(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>FilterCollection</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>FilterCollection</c> to a one-dimensional
		///		<see cref="NLog.Filters.Filter"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Filters.Filter"/> array to copy to.</param>
		public virtual void CopyTo(NLog.Filters.Filter[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>FilterCollection</c> to a one-dimensional
		///		<see cref="NLog.Filters.Filter"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Filters.Filter"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(NLog.Filters.Filter[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="NLog.Filters.Filter"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="FilterCollection.Count"/>.</para>
		/// </exception>
		public virtual NLog.Filters.Filter this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="NLog.Filters.Filter"/> to the end of the <c>FilterCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Filters.Filter"/> to be added to the end of the <c>FilterCollection</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(NLog.Filters.Filter item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>FilterCollection</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new NLog.Filters.Filter[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="FilterCollection"/>.
		/// </summary>
		public virtual object Clone()
		{
			FilterCollection newColl = new FilterCollection(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="NLog.Filters.Filter"/> is in the <c>FilterCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Filters.Filter"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>FilterCollection</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(NLog.Filters.Filter item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="NLog.Filters.Filter"/>
		///		in the <c>FilterCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Filters.Filter"/> to locate in the <c>FilterCollection</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>FilterCollection</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(NLog.Filters.Filter item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>FilterCollection</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="NLog.Filters.Filter"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="FilterCollection.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, NLog.Filters.Filter item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="NLog.Filters.Filter"/> from the <c>FilterCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Filters.Filter"/> to remove from the <c>FilterCollection</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="NLog.Filters.Filter"/> was not found in the <c>FilterCollection</c>.
		/// </exception>
		public virtual void Remove(NLog.Filters.Filter item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>FilterCollection</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="FilterCollection.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			NLog.Filters.Filter[] temp = new NLog.Filters.Filter[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>FilterCollection</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>FilterCollection</c>.</returns>
		public virtual IFilterCollectionEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>FilterCollection</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						NLog.Filters.Filter[] temp = new NLog.Filters.Filter[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new NLog.Filters.Filter[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>FilterCollection</c> to the current <c>FilterCollection</c>.
		/// </summary>
		/// <param name="x">The <c>FilterCollection</c> whose elements should be added to the end of the current <c>FilterCollection</c>.</param>
		/// <returns>The new <see cref="FilterCollection.Count"/> of the <c>FilterCollection</c>.</returns>
		public virtual int AddRange(FilterCollection x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="NLog.Filters.Filter"/> array to the current <c>FilterCollection</c>.
		/// </summary>
		/// <param name="x">The <see cref="NLog.Filters.Filter"/> array whose elements should be added to the end of the <c>FilterCollection</c>.</param>
		/// <returns>The new <see cref="FilterCollection.Count"/> of the <c>FilterCollection</c>.</returns>
		public virtual int AddRange(NLog.Filters.Filter[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="FilterCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="FilterCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (NLog.Filters.Filter)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((NLog.Filters.Filter)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((NLog.Filters.Filter)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((NLog.Filters.Filter)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (NLog.Filters.Filter)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((NLog.Filters.Filter)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="FilterCollection"/>.
		/// </summary>
		private class Enumerator : IEnumerator, IFilterCollectionEnumerator
		{
			#region Implementation (data)
			
			private FilterCollection m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(FilterCollection tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public NLog.Filters.Filter Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncFilterCollection : FilterCollection
        {
            #region Implementation (data)
            private FilterCollection m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncFilterCollection(FilterCollection list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Filters.Filter[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Filters.Filter[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Filters.Filter this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(NLog.Filters.Filter x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(NLog.Filters.Filter x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Filters.Filter x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Filters.Filter x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(NLog.Filters.Filter x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IFilterCollectionEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(FilterCollection x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(NLog.Filters.Filter[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyFilterCollection : FilterCollection
        {
            #region Implementation (data)
            private FilterCollection m_collection;
            #endregion

            #region Construction
            internal ReadOnlyFilterCollection(FilterCollection list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Filters.Filter[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Filters.Filter[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Filters.Filter this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(NLog.Filters.Filter x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(NLog.Filters.Filter x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Filters.Filter x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Filters.Filter x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(NLog.Filters.Filter x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IFilterCollectionEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(FilterCollection x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(NLog.Filters.Filter[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
	
namespace NLog.LayoutAppenders
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="NLog.LayoutAppenders.LayoutAppender"/> objects.
	/// </summary>
	[Serializable]
public 
  class LayoutAppenderCollection : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="LayoutAppenderCollection"/>.
	    /// </summary>
        public interface ILayoutAppenderCollectionEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            NLog.LayoutAppenders.LayoutAppender Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private NLog.LayoutAppenders.LayoutAppender[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>LayoutAppenderCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>LayoutAppenderCollection</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static LayoutAppenderCollection Synchronized(LayoutAppenderCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncLayoutAppenderCollection(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>LayoutAppenderCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>LayoutAppenderCollection</c> wrapper that is read-only.
		/// </returns>
        public static LayoutAppenderCollection ReadOnly(LayoutAppenderCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyLayoutAppenderCollection(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>LayoutAppenderCollection</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public LayoutAppenderCollection()
		{
			m_array = new NLog.LayoutAppenders.LayoutAppender[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>LayoutAppenderCollection</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>LayoutAppenderCollection</c> is initially capable of storing.
		///	</param>
		public LayoutAppenderCollection(int capacity)
		{
			m_array = new NLog.LayoutAppenders.LayoutAppender[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>LayoutAppenderCollection</c> class
		///		that contains elements copied from the specified <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="c">The <c>LayoutAppenderCollection</c> whose elements are copied to the new collection.</param>
		public LayoutAppenderCollection(LayoutAppenderCollection c)
		{
			m_array = new NLog.LayoutAppenders.LayoutAppender[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>LayoutAppenderCollection</c> class
		///		that contains elements copied from the specified <see cref="NLog.LayoutAppenders.LayoutAppender"/> array.
		/// </summary>
		/// <param name="a">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> array whose elements are copied to the new list.</param>
		public LayoutAppenderCollection(NLog.LayoutAppenders.LayoutAppender[] a)
		{
			m_array = new NLog.LayoutAppenders.LayoutAppender[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected LayoutAppenderCollection(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>LayoutAppenderCollection</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>LayoutAppenderCollection</c> to a one-dimensional
		///		<see cref="NLog.LayoutAppenders.LayoutAppender"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.LayoutAppenders.LayoutAppender"/> array to copy to.</param>
		public virtual void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>LayoutAppenderCollection</c> to a one-dimensional
		///		<see cref="NLog.LayoutAppenders.LayoutAppender"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.LayoutAppenders.LayoutAppender"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="NLog.LayoutAppenders.LayoutAppender"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="LayoutAppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual NLog.LayoutAppenders.LayoutAppender this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="NLog.LayoutAppenders.LayoutAppender"/> to the end of the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> to be added to the end of the <c>LayoutAppenderCollection</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(NLog.LayoutAppenders.LayoutAppender item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>LayoutAppenderCollection</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new NLog.LayoutAppenders.LayoutAppender[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="LayoutAppenderCollection"/>.
		/// </summary>
		public virtual object Clone()
		{
			LayoutAppenderCollection newColl = new LayoutAppenderCollection(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="NLog.LayoutAppenders.LayoutAppender"/> is in the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>LayoutAppenderCollection</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(NLog.LayoutAppenders.LayoutAppender item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="NLog.LayoutAppenders.LayoutAppender"/>
		///		in the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> to locate in the <c>LayoutAppenderCollection</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>LayoutAppenderCollection</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(NLog.LayoutAppenders.LayoutAppender item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>LayoutAppenderCollection</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="LayoutAppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, NLog.LayoutAppenders.LayoutAppender item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="NLog.LayoutAppenders.LayoutAppender"/> from the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> to remove from the <c>LayoutAppenderCollection</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="NLog.LayoutAppenders.LayoutAppender"/> was not found in the <c>LayoutAppenderCollection</c>.
		/// </exception>
		public virtual void Remove(NLog.LayoutAppenders.LayoutAppender item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="LayoutAppenderCollection.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			NLog.LayoutAppenders.LayoutAppender[] temp = new NLog.LayoutAppenders.LayoutAppender[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>LayoutAppenderCollection</c>.</returns>
		public virtual ILayoutAppenderCollectionEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>LayoutAppenderCollection</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						NLog.LayoutAppenders.LayoutAppender[] temp = new NLog.LayoutAppenders.LayoutAppender[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new NLog.LayoutAppenders.LayoutAppender[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>LayoutAppenderCollection</c> to the current <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="x">The <c>LayoutAppenderCollection</c> whose elements should be added to the end of the current <c>LayoutAppenderCollection</c>.</param>
		/// <returns>The new <see cref="LayoutAppenderCollection.Count"/> of the <c>LayoutAppenderCollection</c>.</returns>
		public virtual int AddRange(LayoutAppenderCollection x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="NLog.LayoutAppenders.LayoutAppender"/> array to the current <c>LayoutAppenderCollection</c>.
		/// </summary>
		/// <param name="x">The <see cref="NLog.LayoutAppenders.LayoutAppender"/> array whose elements should be added to the end of the <c>LayoutAppenderCollection</c>.</param>
		/// <returns>The new <see cref="LayoutAppenderCollection.Count"/> of the <c>LayoutAppenderCollection</c>.</returns>
		public virtual int AddRange(NLog.LayoutAppenders.LayoutAppender[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="LayoutAppenderCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="LayoutAppenderCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (NLog.LayoutAppenders.LayoutAppender)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((NLog.LayoutAppenders.LayoutAppender)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((NLog.LayoutAppenders.LayoutAppender)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((NLog.LayoutAppenders.LayoutAppender)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (NLog.LayoutAppenders.LayoutAppender)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((NLog.LayoutAppenders.LayoutAppender)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="LayoutAppenderCollection"/>.
		/// </summary>
		private class Enumerator : IEnumerator, ILayoutAppenderCollectionEnumerator
		{
			#region Implementation (data)
			
			private LayoutAppenderCollection m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(LayoutAppenderCollection tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public NLog.LayoutAppenders.LayoutAppender Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncLayoutAppenderCollection : LayoutAppenderCollection
        {
            #region Implementation (data)
            private LayoutAppenderCollection m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncLayoutAppenderCollection(LayoutAppenderCollection list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.LayoutAppenders.LayoutAppender this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(NLog.LayoutAppenders.LayoutAppender x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(NLog.LayoutAppenders.LayoutAppender x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.LayoutAppenders.LayoutAppender x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.LayoutAppenders.LayoutAppender x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(NLog.LayoutAppenders.LayoutAppender x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override ILayoutAppenderCollectionEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(LayoutAppenderCollection x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(NLog.LayoutAppenders.LayoutAppender[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyLayoutAppenderCollection : LayoutAppenderCollection
        {
            #region Implementation (data)
            private LayoutAppenderCollection m_collection;
            #endregion

            #region Construction
            internal ReadOnlyLayoutAppenderCollection(LayoutAppenderCollection list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.LayoutAppenders.LayoutAppender[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.LayoutAppenders.LayoutAppender this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(NLog.LayoutAppenders.LayoutAppender x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(NLog.LayoutAppenders.LayoutAppender x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.LayoutAppenders.LayoutAppender x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.LayoutAppenders.LayoutAppender x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(NLog.LayoutAppenders.LayoutAppender x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override ILayoutAppenderCollectionEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(LayoutAppenderCollection x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(NLog.LayoutAppenders.LayoutAppender[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
	
namespace NLog.Config
{
	

	/// <summary>
	///		A strongly-typed collection of <see cref="NLog.Config.AppenderRule"/> objects.
	/// </summary>
	[Serializable]
public 
  class AppenderRuleCollection : ICollection, IList, IEnumerable, ICloneable
	{
        #region Interfaces
	    /// <summary>
	    ///		Supports type-safe iteration over a <see cref="AppenderRuleCollection"/>.
	    /// </summary>
        public interface IAppenderRuleCollectionEnumerator
        {
		    /// <summary>
		    ///		Gets the current element in the collection.
		    /// </summary>
            NLog.Config.AppenderRule Current {get;}

		    /// <summary>
		    ///		Advances the enumerator to the next element in the collection.
		    /// </summary>
		    /// <exception cref="InvalidOperationException">
		    ///		The collection was modified after the enumerator was created.
		    /// </exception>
		    /// <returns>
		    ///		<c>true</c> if the enumerator was successfully advanced to the next element; 
		    ///		<c>false</c> if the enumerator has passed the end of the collection.
		    /// </returns>
            bool MoveNext();

		    /// <summary>
		    ///		Sets the enumerator to its initial position, before the first element in the collection.
		    /// </summary>
            void Reset();
        }
        #endregion

		private const int DEFAULT_CAPACITY = 16;

		#region Implementation (data)
		private NLog.Config.AppenderRule[] m_array;
		private int m_count = 0;
		[NonSerialized]
		private int m_version = 0;
		#endregion
	
        #region Static Wrappers
		/// <summary>
		///		Creates a synchronized (thread-safe) wrapper for a 
		///     <c>AppenderRuleCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>AppenderRuleCollection</c> wrapper that is synchronized (thread-safe).
		/// </returns>
        public static AppenderRuleCollection Synchronized(AppenderRuleCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new SyncAppenderRuleCollection(list);
        }
        
		/// <summary>
		///		Creates a read-only wrapper for a 
		///     <c>AppenderRuleCollection</c> instance.
		/// </summary>
		/// <returns>
		///     An <c>AppenderRuleCollection</c> wrapper that is read-only.
		/// </returns>
        public static AppenderRuleCollection ReadOnly(AppenderRuleCollection list)
        {
            if(list==null)
                throw new ArgumentNullException("list");
            return new ReadOnlyAppenderRuleCollection(list);
        }
        #endregion

	    #region Construction
		/// <summary>
		///		Initializes a new instance of the <c>AppenderRuleCollection</c> class
		///		that is empty and has the default initial capacity.
		/// </summary>
		public AppenderRuleCollection()
		{
			m_array = new NLog.Config.AppenderRule[DEFAULT_CAPACITY];
		}
		
		/// <summary>
		///		Initializes a new instance of the <c>AppenderRuleCollection</c> class
		///		that has the specified initial capacity.
		/// </summary>
		/// <param name="capacity">
		///		The number of elements that the new <c>AppenderRuleCollection</c> is initially capable of storing.
		///	</param>
		public AppenderRuleCollection(int capacity)
		{
			m_array = new NLog.Config.AppenderRule[capacity];
		}

		/// <summary>
		///		Initializes a new instance of the <c>AppenderRuleCollection</c> class
		///		that contains elements copied from the specified <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="c">The <c>AppenderRuleCollection</c> whose elements are copied to the new collection.</param>
		public AppenderRuleCollection(AppenderRuleCollection c)
		{
			m_array = new NLog.Config.AppenderRule[c.Count];
			AddRange(c);
		}

		/// <summary>
		///		Initializes a new instance of the <c>AppenderRuleCollection</c> class
		///		that contains elements copied from the specified <see cref="NLog.Config.AppenderRule"/> array.
		/// </summary>
		/// <param name="a">The <see cref="NLog.Config.AppenderRule"/> array whose elements are copied to the new list.</param>
		public AppenderRuleCollection(NLog.Config.AppenderRule[] a)
		{
			m_array = new NLog.Config.AppenderRule[a.Length];
			AddRange(a);
		}
		
        protected enum Tag {
            Default
        }

        protected AppenderRuleCollection(Tag t)
        {
            m_array = null;
        }
		#endregion
		
		#region Operations (type-safe ICollection)
		/// <summary>
		///		Gets the number of elements actually contained in the <c>AppenderRuleCollection</c>.
		/// </summary>
		public virtual int Count
		{
			get { return m_count; }
		}

		/// <summary>
		///		Copies the entire <c>AppenderRuleCollection</c> to a one-dimensional
		///		<see cref="NLog.Config.AppenderRule"/> array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Config.AppenderRule"/> array to copy to.</param>
		public virtual void CopyTo(NLog.Config.AppenderRule[] array)
		{
			this.CopyTo(array, 0);
		}

		/// <summary>
		///		Copies the entire <c>AppenderRuleCollection</c> to a one-dimensional
		///		<see cref="NLog.Config.AppenderRule"/> array, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="NLog.Config.AppenderRule"/> array to copy to.</param>
		/// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
		public virtual void CopyTo(NLog.Config.AppenderRule[] array, int start)
		{
			if (m_count > array.GetUpperBound(0) + 1 - start)
				throw new System.ArgumentException("Destination array was not long enough.");
			
			Array.Copy(m_array, 0, array, start, m_count); 
		}

		/// <summary>
		///		Gets a value indicating whether access to the collection is synchronized (thread-safe).
		/// </summary>
		/// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get { return m_array.IsSynchronized; }
        }

        /// <summary>
		///		Gets an object that can be used to synchronize access to the collection.
		/// </summary>
        public virtual object SyncRoot
        {
            get { return m_array.SyncRoot; }
        }
		#endregion
		
		#region Operations (type-safe IList)
		/// <summary>
		///		Gets or sets the <see cref="NLog.Config.AppenderRule"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderRuleCollection.Count"/>.</para>
		/// </exception>
		public virtual NLog.Config.AppenderRule this[int index]
		{
			get
			{
				ValidateIndex(index); // throws
				return m_array[index]; 
			}
			set
			{
				ValidateIndex(index); // throws
				++m_version; 
				m_array[index] = value; 
			}
		}

		/// <summary>
		///		Adds a <see cref="NLog.Config.AppenderRule"/> to the end of the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Config.AppenderRule"/> to be added to the end of the <c>AppenderRuleCollection</c>.</param>
		/// <returns>The index at which the value has been added.</returns>
		public virtual int Add(NLog.Config.AppenderRule item)
		{
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			m_array[m_count] = item;
			m_version++;

			return m_count++;
		}
		
		/// <summary>
		///		Removes all elements from the <c>AppenderRuleCollection</c>.
		/// </summary>
		public virtual void Clear()
		{
			++m_version;
			m_array = new NLog.Config.AppenderRule[DEFAULT_CAPACITY];
			m_count = 0;
		}
		
		/// <summary>
		///		Creates a shallow copy of the <see cref="AppenderRuleCollection"/>.
		/// </summary>
		public virtual object Clone()
		{
			AppenderRuleCollection newColl = new AppenderRuleCollection(m_count);
			Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
			newColl.m_count = m_count;
			newColl.m_version = m_version;

			return newColl;
		}

		/// <summary>
		///		Determines whether a given <see cref="NLog.Config.AppenderRule"/> is in the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Config.AppenderRule"/> to check for.</param>
		/// <returns><c>true</c> if <paramref name="item"/> is found in the <c>AppenderRuleCollection</c>; otherwise, <c>false</c>.</returns>
		public virtual bool Contains(NLog.Config.AppenderRule item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return true;
			return false;
		}

		/// <summary>
		///		Returns the zero-based index of the first occurrence of a <see cref="NLog.Config.AppenderRule"/>
		///		in the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Config.AppenderRule"/> to locate in the <c>AppenderRuleCollection</c>.</param>
		/// <returns>
		///		The zero-based index of the first occurrence of <paramref name="item"/> 
		///		in the entire <c>AppenderRuleCollection</c>, if found; otherwise, -1.
		///	</returns>
		public virtual int IndexOf(NLog.Config.AppenderRule item)
		{
			for (int i=0; i != m_count; ++i)
				if (m_array[i].Equals(item))
					return i;
			return -1;
		}

		/// <summary>
		///		Inserts an element into the <c>AppenderRuleCollection</c> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
		/// <param name="item">The <see cref="NLog.Config.AppenderRule"/> to insert.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderRuleCollection.Count"/>.</para>
		/// </exception>
		public virtual void Insert(int index, NLog.Config.AppenderRule item)
		{
			ValidateIndex(index, true); // throws
			
			if (m_count == m_array.Length)
				EnsureCapacity(m_count + 1);

			if (index < m_count)
			{
				Array.Copy(m_array, index, m_array, index + 1, m_count - index);
			}

			m_array[index] = item;
			m_count++;
			m_version++;
		}

		/// <summary>
		///		Removes the first occurrence of a specific <see cref="NLog.Config.AppenderRule"/> from the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="item">The <see cref="NLog.Config.AppenderRule"/> to remove from the <c>AppenderRuleCollection</c>.</param>
		/// <exception cref="ArgumentException">
		///		The specified <see cref="NLog.Config.AppenderRule"/> was not found in the <c>AppenderRuleCollection</c>.
		/// </exception>
		public virtual void Remove(NLog.Config.AppenderRule item)
		{		   
			int i = IndexOf(item);
			if (i < 0)
				throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
			
			++m_version;
			RemoveAt(i);
		}

		/// <summary>
		///		Removes the element at the specified index of the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderRuleCollection.Count"/>.</para>
		/// </exception>
		public virtual void RemoveAt(int index)
		{
			ValidateIndex(index); // throws
			
			m_count--;

			if (index < m_count)
			{
				Array.Copy(m_array, index + 1, m_array, index, m_count - index);
			}
			
			// We can't set the deleted entry equal to null, because it might be a value type.
			// Instead, we'll create an empty single-element array of the right type and copy it 
			// over the entry we want to erase.
			NLog.Config.AppenderRule[] temp = new NLog.Config.AppenderRule[1];
			Array.Copy(temp, 0, m_array, m_count, 1);
			m_version++;
		}

		/// <summary>
		///		Gets a value indicating whether the collection has a fixed size.
		/// </summary>
		/// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get { return false; }
        }

		/// <summary>
		///		gets a value indicating whether the IList is read-only.
		/// </summary>
		/// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get { return false; }
        }
		#endregion

		#region Operations (type-safe IEnumerable)
		
		/// <summary>
		///		Returns an enumerator that can iterate through the <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <returns>An <see cref="Enumerator"/> for the entire <c>AppenderRuleCollection</c>.</returns>
		public virtual IAppenderRuleCollectionEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}
		#endregion

		#region Public helpers (just to mimic some nice features of ArrayList)
		
		/// <summary>
		///		Gets or sets the number of elements the <c>AppenderRuleCollection</c> can contain.
		/// </summary>
		public virtual int Capacity
		{
			get { return m_array.Length; }
			
			set
			{
				if (value < m_count)
					value = m_count;

				if (value != m_array.Length)
				{
					if (value > 0)
					{
						NLog.Config.AppenderRule[] temp = new NLog.Config.AppenderRule[value];
						Array.Copy(m_array, temp, m_count);
						m_array = temp;
					}
					else
					{
						m_array = new NLog.Config.AppenderRule[DEFAULT_CAPACITY];
					}
				}
			}
		}

		/// <summary>
		///		Adds the elements of another <c>AppenderRuleCollection</c> to the current <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="x">The <c>AppenderRuleCollection</c> whose elements should be added to the end of the current <c>AppenderRuleCollection</c>.</param>
		/// <returns>The new <see cref="AppenderRuleCollection.Count"/> of the <c>AppenderRuleCollection</c>.</returns>
		public virtual int AddRange(AppenderRuleCollection x)
		{
			if (m_count + x.Count >= m_array.Length)
				EnsureCapacity(m_count + x.Count);
			
			Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
			m_count += x.Count;
			m_version++;

			return m_count;
		}

		/// <summary>
		///		Adds the elements of a <see cref="NLog.Config.AppenderRule"/> array to the current <c>AppenderRuleCollection</c>.
		/// </summary>
		/// <param name="x">The <see cref="NLog.Config.AppenderRule"/> array whose elements should be added to the end of the <c>AppenderRuleCollection</c>.</param>
		/// <returns>The new <see cref="AppenderRuleCollection.Count"/> of the <c>AppenderRuleCollection</c>.</returns>
		public virtual int AddRange(NLog.Config.AppenderRule[] x)
		{
			if (m_count + x.Length >= m_array.Length)
				EnsureCapacity(m_count + x.Length);

			Array.Copy(x, 0, m_array, m_count, x.Length);
			m_count += x.Length;
			m_version++;

			return m_count;
		}
		
		/// <summary>
		///		Sets the capacity to the actual number of elements.
		/// </summary>
		public virtual void TrimToSize()
		{
			this.Capacity = m_count;
		}

		#endregion

		#region Implementation (helpers)

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderRuleCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i)
		{
			ValidateIndex(i, false);
		}

		/// <exception cref="ArgumentOutOfRangeException">
		///		<para><paramref name="index"/> is less than zero</para>
		///		<para>-or-</para>
		///		<para><paramref name="index"/> is equal to or greater than <see cref="AppenderRuleCollection.Count"/>.</para>
		/// </exception>
		private void ValidateIndex(int i, bool allowEqualEnd)
		{
			int max = (allowEqualEnd)?(m_count):(m_count-1);
			if (i < 0 || i > max)
				throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
		}

		private void EnsureCapacity(int min)
		{
			int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
			if (newCapacity < min)
				newCapacity = min;

			this.Capacity = newCapacity;
		}

		#endregion
		
		#region Implementation (ICollection)

		void ICollection.CopyTo(Array array, int start)
		{
			Array.Copy(m_array, 0, array, start, m_count);
		}

		#endregion

		#region Implementation (IList)

		object IList.this[int i]
		{
			get { return (object)this[i]; }
			set { this[i] = (NLog.Config.AppenderRule)value; }
		}

		int IList.Add(object x)
		{
			return this.Add((NLog.Config.AppenderRule)x);
		}

    	bool IList.Contains(object x)
		{
			return this.Contains((NLog.Config.AppenderRule)x);
		}

		int IList.IndexOf(object x)
		{
			return this.IndexOf((NLog.Config.AppenderRule)x);
		}

		void IList.Insert(int pos, object x)
		{
			this.Insert(pos, (NLog.Config.AppenderRule)x);
		}

		void IList.Remove(object x)
		{
			this.Remove((NLog.Config.AppenderRule)x);
		}

		void IList.RemoveAt(int pos)
		{
			this.RemoveAt(pos);
		}

		#endregion

		#region Implementation (IEnumerable)

		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(this.GetEnumerator());
		}

		#endregion

		#region Nested enumerator class
		/// <summary>
		///		Supports simple iteration over a <see cref="AppenderRuleCollection"/>.
		/// </summary>
		private class Enumerator : IEnumerator, IAppenderRuleCollectionEnumerator
		{
			#region Implementation (data)
			
			private AppenderRuleCollection m_collection;
			private int m_index;
			private int m_version;
			
			#endregion
		
			#region Construction
			
			/// <summary>
			///		Initializes a new instance of the <c>Enumerator</c> class.
			/// </summary>
			/// <param name="tc"></param>
			internal Enumerator(AppenderRuleCollection tc)
			{
				m_collection = tc;
				m_index = -1;
				m_version = tc.m_version;
			}
			
			#endregion
	
			#region Operations (type-safe IEnumerator)
			
			/// <summary>
			///		Gets the current element in the collection.
			/// </summary>
			public NLog.Config.AppenderRule Current
			{
				get { return m_collection[m_index]; }
			}

			/// <summary>
			///		Advances the enumerator to the next element in the collection.
			/// </summary>
			/// <exception cref="InvalidOperationException">
			///		The collection was modified after the enumerator was created.
			/// </exception>
			/// <returns>
			///		<c>true</c> if the enumerator was successfully advanced to the next element; 
			///		<c>false</c> if the enumerator has passed the end of the collection.
			/// </returns>
			public bool MoveNext()
			{
				if (m_version != m_collection.m_version)
					throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

				++m_index;
				return (m_index < m_collection.Count) ? true : false;
			}

			/// <summary>
			///		Sets the enumerator to its initial position, before the first element in the collection.
			/// </summary>
			public void Reset()
			{
				m_index = -1;
			}
			#endregion
	
			#region Implementation (IEnumerator)
			
			object IEnumerator.Current
			{
				get { return (object)(this.Current); }
			}
			
			#endregion
		}
        #endregion
        
        #region Nested Syncronized Wrapper class
        private class SyncAppenderRuleCollection : AppenderRuleCollection
        {
            #region Implementation (data)
            private AppenderRuleCollection m_collection;
            private object m_root;
            #endregion

            #region Construction
            internal SyncAppenderRuleCollection(AppenderRuleCollection list) : base(Tag.Default)
            {
                m_root = list.SyncRoot;
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Config.AppenderRule[] array)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Config.AppenderRule[] array, int start)
            {
                lock(this.m_root)
                    m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get
                { 
                    lock(this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get { return true; }
            }

            public override object SyncRoot
            {
                get { return this.m_root; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Config.AppenderRule this[int i]
            {
                get
                {
                    lock(this.m_root)
                        return m_collection[i];
                }
                set
                {
                    lock(this.m_root)
                        m_collection[i] = value; 
                }
            }

            public override int Add(NLog.Config.AppenderRule x)
            {
                lock(this.m_root)
                    return m_collection.Add(x);
            }
            
            public override void Clear()
            {
                lock(this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(NLog.Config.AppenderRule x)
            {
                lock(this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Config.AppenderRule x)
            {
                lock(this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Config.AppenderRule x)
            {
                lock(this.m_root)
                    m_collection.Insert(pos,x);
            }

            public override void Remove(NLog.Config.AppenderRule x)
            {           
                lock(this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos)
            {
                lock(this.m_root)
                    m_collection.RemoveAt(pos);
            }
            
            public override bool IsFixedSize
            {
                get {return m_collection.IsFixedSize;}
            }

            public override bool IsReadOnly
            {
                get {return m_collection.IsReadOnly;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IAppenderRuleCollectionEnumerator GetEnumerator()
            {
                lock(m_root)
                    return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get
                {
                    lock(this.m_root)
                        return m_collection.Capacity;
                }
                
                set
                {
                    lock(this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(AppenderRuleCollection x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(NLog.Config.AppenderRule[] x)
            {
                lock(this.m_root)
                    return m_collection.AddRange(x);
            }
            #endregion
        }
        #endregion

        #region Nested Read Only Wrapper class
        private class ReadOnlyAppenderRuleCollection : AppenderRuleCollection
        {
            #region Implementation (data)
            private AppenderRuleCollection m_collection;
            #endregion

            #region Construction
            internal ReadOnlyAppenderRuleCollection(AppenderRuleCollection list) : base(Tag.Default)
            {
                m_collection = list;
            }
            #endregion
            
            #region Type-safe ICollection
            public override void CopyTo(NLog.Config.AppenderRule[] array)
            {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(NLog.Config.AppenderRule[] array, int start)
            {
                m_collection.CopyTo(array,start);
            }
            public override int Count
            {
                get {return m_collection.Count;}
            }

            public override bool IsSynchronized
            {
                get { return m_collection.IsSynchronized; }
            }

            public override object SyncRoot
            {
                get { return this.m_collection.SyncRoot; }
            }
            #endregion
            
            #region Type-safe IList
            public override NLog.Config.AppenderRule this[int i]
            {
                get { return m_collection[i]; }
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int Add(NLog.Config.AppenderRule x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override void Clear()
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(NLog.Config.AppenderRule x)
            {
                return m_collection.Contains(x);
            }

            public override int IndexOf(NLog.Config.AppenderRule x)
            {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, NLog.Config.AppenderRule x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(NLog.Config.AppenderRule x)
            {           
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            
            public override bool IsFixedSize
            {
                get {return true;}
            }

            public override bool IsReadOnly
            {
                get {return true;}
            }
            #endregion

            #region Type-safe IEnumerable
            public override IAppenderRuleCollectionEnumerator GetEnumerator()
            {
                return m_collection.GetEnumerator();
            }
            #endregion

            #region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get { return m_collection.Capacity; }
                
                set { throw new NotSupportedException("This is a Read Only Collection and can not be modified"); }
            }

            public override int AddRange(AppenderRuleCollection x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(NLog.Config.AppenderRule[] x)
            {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
            #endregion
        }
        #endregion
	}

}
namespace NLog.Internal
{
	public 
	class LoggerDictionary : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  LoggerDictionary()
		{
			innerHash = new Hashtable();
		}
		public LoggerDictionary(LoggerDictionary original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public LoggerDictionary(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public LoggerDictionary(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public LoggerDictionary(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public LoggerDictionary(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public LoggerDictionary(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public LoggerDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public LoggerDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public LoggerDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public LoggerDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public LoggerDictionaryEnumerator GetEnumerator()
        {
	        return new LoggerDictionaryEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new LoggerDictionaryEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, NLog.Logger value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (NLog.Logger)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public NLog.Logger this[string key]
		{
			get
			{
				return (NLog.Logger) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (NLog.Logger)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public LoggerDictionary Clone()
		{
			LoggerDictionary clone = new LoggerDictionary();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (NLog.Logger value)
		{
			return innerHash.ContainsValue(value);
		}
		public static LoggerDictionary Synchronized(LoggerDictionary nonSync)
		{
			LoggerDictionary sync = new LoggerDictionary();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class LoggerDictionaryEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal LoggerDictionaryEnumerator (LoggerDictionary enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public NLog.Logger Value
		{
			get
			{
				return (NLog.Logger)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
	
namespace NLog.Internal
{
	public 
	class TypeDictionary : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  TypeDictionary()
		{
			innerHash = new Hashtable();
		}
		public TypeDictionary(TypeDictionary original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public TypeDictionary(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public TypeDictionary(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public TypeDictionary(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public TypeDictionary(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public TypeDictionary(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public TypeDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public TypeDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public TypeDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public TypeDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public TypeDictionaryEnumerator GetEnumerator()
        {
	        return new TypeDictionaryEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new TypeDictionaryEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, System.Type value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (System.Type)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public System.Type this[string key]
		{
			get
			{
				return (System.Type) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (System.Type)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public TypeDictionary Clone()
		{
			TypeDictionary clone = new TypeDictionary();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (System.Type value)
		{
			return innerHash.ContainsValue(value);
		}
		public static TypeDictionary Synchronized(TypeDictionary nonSync)
		{
			TypeDictionary sync = new TypeDictionary();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class TypeDictionaryEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal TypeDictionaryEnumerator (TypeDictionary enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public System.Type Value
		{
			get
			{
				return (System.Type)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
	
namespace NLog.Internal
{
	public 
	class AppenderDictionary : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  AppenderDictionary()
		{
			innerHash = new Hashtable();
		}
		public AppenderDictionary(AppenderDictionary original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public AppenderDictionary(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public AppenderDictionary(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public AppenderDictionary(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public AppenderDictionary(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public AppenderDictionary(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public AppenderDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public AppenderDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public AppenderDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public AppenderDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public AppenderDictionaryEnumerator GetEnumerator()
        {
	        return new AppenderDictionaryEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new AppenderDictionaryEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, NLog.Appenders.Appender value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (NLog.Appenders.Appender)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public NLog.Appenders.Appender this[string key]
		{
			get
			{
				return (NLog.Appenders.Appender) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (NLog.Appenders.Appender)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public AppenderDictionary Clone()
		{
			AppenderDictionary clone = new AppenderDictionary();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (NLog.Appenders.Appender value)
		{
			return innerHash.ContainsValue(value);
		}
		public static AppenderDictionary Synchronized(AppenderDictionary nonSync)
		{
			AppenderDictionary sync = new AppenderDictionary();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class AppenderDictionaryEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal AppenderDictionaryEnumerator (AppenderDictionary enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public NLog.Appenders.Appender Value
		{
			get
			{
				return (NLog.Appenders.Appender)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
	
namespace NLog.Internal
{
	public 
	class LayoutAppenderDictionary : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  LayoutAppenderDictionary()
		{
			innerHash = new Hashtable();
		}
		public LayoutAppenderDictionary(LayoutAppenderDictionary original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public LayoutAppenderDictionary(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public LayoutAppenderDictionary(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public LayoutAppenderDictionary(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public LayoutAppenderDictionary(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public LayoutAppenderDictionary(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public LayoutAppenderDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public LayoutAppenderDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public LayoutAppenderDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public LayoutAppenderDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public LayoutAppenderDictionaryEnumerator GetEnumerator()
        {
	        return new LayoutAppenderDictionaryEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new LayoutAppenderDictionaryEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, NLog.LayoutAppenders.LayoutAppender value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (NLog.LayoutAppenders.LayoutAppender)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public NLog.LayoutAppenders.LayoutAppender this[string key]
		{
			get
			{
				return (NLog.LayoutAppenders.LayoutAppender) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (NLog.LayoutAppenders.LayoutAppender)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public LayoutAppenderDictionary Clone()
		{
			LayoutAppenderDictionary clone = new LayoutAppenderDictionary();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (NLog.LayoutAppenders.LayoutAppender value)
		{
			return innerHash.ContainsValue(value);
		}
		public static LayoutAppenderDictionary Synchronized(LayoutAppenderDictionary nonSync)
		{
			LayoutAppenderDictionary sync = new LayoutAppenderDictionary();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class LayoutAppenderDictionaryEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal LayoutAppenderDictionaryEnumerator (LayoutAppenderDictionary enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public NLog.LayoutAppenders.LayoutAppender Value
		{
			get
			{
				return (NLog.LayoutAppenders.LayoutAppender)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}
	
namespace NLog.Internal
{
	public 
	class FilterDictionary : IDictionary, ICollection, IEnumerable, ICloneable
	{
		protected Hashtable innerHash;
		
		#region "Constructors"
		public  FilterDictionary()
		{
			innerHash = new Hashtable();
		}
		public FilterDictionary(FilterDictionary original)
		{
			innerHash = new Hashtable (original.innerHash);
		}
		public FilterDictionary(IDictionary dictionary)
		{
			innerHash = new Hashtable (dictionary);
		}

		public FilterDictionary(int capacity)
		{
			innerHash = new Hashtable(capacity);
		}

		public FilterDictionary(IDictionary dictionary, float loadFactor)
		{
			innerHash = new Hashtable(dictionary, loadFactor);
		}

		public FilterDictionary(IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (codeProvider, comparer);
		}

		public FilterDictionary(int capacity, int loadFactor)
		{
			innerHash = new Hashtable(capacity, loadFactor);
		}

		public FilterDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, codeProvider, comparer);
		}
		
		public FilterDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, codeProvider, comparer);
		}

		public FilterDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
		}

		public FilterDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer)
		{
			innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
		}

		
#endregion

		#region Implementation of IDictionary
        public FilterDictionaryEnumerator GetEnumerator()
        {
	        return new FilterDictionaryEnumerator(this);
        }
        
		System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return new FilterDictionaryEnumerator(this);
		}
		
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Remove(string key)
		{
			innerHash.Remove (key);
		}
		void IDictionary.Remove(object key)
		{
			Remove ((string)key);
		}

		public bool Contains(string key)
		{
			return innerHash.Contains(key);
		}
		bool IDictionary.Contains(object key)
		{
			return Contains((string)key);
		}

		public void Clear()
		{
			innerHash.Clear();		
		}

		public void Add(string key, NLog.Filters.Filter value)
		{
			innerHash.Add (key, value);
		}
		void IDictionary.Add(object key, object value)
		{
			Add ((string)key, (NLog.Filters.Filter)value);
		}

		public bool IsReadOnly
		{
			get
			{
				return innerHash.IsReadOnly;
			}
		}

		public NLog.Filters.Filter this[string key]
		{
			get
			{
				return (NLog.Filters.Filter) innerHash[key];
			}
			set
			{
				innerHash[key] = value;
			}
		}
		object IDictionary.this[object key]
		{
			get
			{
				return this[(string)key];
			}
			set
			{
				this[(string)key] = (NLog.Filters.Filter)value;
			}
		}
        
		public System.Collections.ICollection Values
		{
			get
			{
				return innerHash.Values;
			}
		}

		public System.Collections.ICollection Keys
		{
			get
			{
				return innerHash.Keys;
			}
		}

		public bool IsFixedSize
		{
			get
			{
				return innerHash.IsFixedSize;
			}
		}
		#endregion

		#region Implementation of ICollection
		public void CopyTo(System.Array array, int index)
		{
			innerHash.CopyTo (array, index);
		}

		public bool IsSynchronized
		{
			get
			{
				return innerHash.IsSynchronized;
			}
		}

		public int Count
		{
			get
			{
				return innerHash.Count;
			}
		}

		public object SyncRoot
		{
			get
			{
				return innerHash.SyncRoot;
			}
		}
		#endregion

		#region Implementation of ICloneable
		public FilterDictionary Clone()
		{
			FilterDictionary clone = new FilterDictionary();
			clone.innerHash = (Hashtable) innerHash.Clone();
			
			return clone;
		}
		object ICloneable.Clone()
		{
			return Clone();
		}
		#endregion
		
		#region "HashTable Methods"
		public bool ContainsKey (string key)
		{
			return innerHash.ContainsKey(key);
		}
		public bool ContainsValue (NLog.Filters.Filter value)
		{
			return innerHash.ContainsValue(value);
		}
		public static FilterDictionary Synchronized(FilterDictionary nonSync)
		{
			FilterDictionary sync = new FilterDictionary();
			sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

			return sync;
		}
		#endregion

		internal Hashtable InnerHash
		{
			get
			{
				return innerHash;
			}
		}
	}
	
	public class FilterDictionaryEnumerator : IDictionaryEnumerator
	{
		private IDictionaryEnumerator innerEnumerator;
			
		internal FilterDictionaryEnumerator (FilterDictionary enumerable)
		{
			innerEnumerator = enumerable.InnerHash.GetEnumerator();
		}

		#region Implementation of IDictionaryEnumerator
		public string Key
		{
			get
			{
				return (string)innerEnumerator.Key;
			}
		}
		object IDictionaryEnumerator.Key
		 {
			 get
			 {
				 return Key;
			 }
		 }


		public NLog.Filters.Filter Value
		{
			get
			{
				return (NLog.Filters.Filter)innerEnumerator.Value;
			}
		}
		object IDictionaryEnumerator.Value
		{
			get
			{
				return Value;
			}
		}

		public System.Collections.DictionaryEntry Entry
		{
			get
			{
				return innerEnumerator.Entry;
			}
		}

		#endregion

		#region Implementation of IEnumerator
		public void Reset()
		{
			innerEnumerator.Reset();
		}

		public bool MoveNext()
		{
			return innerEnumerator.MoveNext();
		}

		public object Current
		{
			get
			{
				return innerEnumerator.Current;
			}
		}
		#endregion
	}

}